---
title: "Analysis of UAC data"
output:
  bookdown::html_document2:
    css: .formatting/grattan-style.css
    theme: lumen
    highlight: pygments
    toc: yes
    toc_depth: 2
    toc_float: no
    number_sections: yes
    df_print: kable
---

```{r logo, echo=FALSE}
# This adds the grattan logo to the document (cute)
htmltools::img(src = knitr::image_uri(file.path(".formatting", "logo", "GrattanLogo_left.png")), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; height:8%;')
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE, 
                      message = FALSE)

source("R/00-setup.R") 

rebuild_data <- FALSE
```

# Import data

```{r}

#Upload the !!Preliminary!! course list provided to Grattan. 
#Note - UAC subsequently filtered that down, in the data set ultimately provided to us, using filters: field of study code (broad FOS = 7) or any course with description including the string “Educat” or “Teach”. 
#Pull data from MT Teams folder, as gitignore is set to ignore data folder, and these will be lost when we change branches.

user_data_folder <- "C:/Users/PETRIE/The University of Melbourne/2024 Primary schools maths - General/3. Data/4. Uni entry data/"
#"C:/Users/parkinsonn/The University of Melbourne/2024 Primary schools maths - General/3. Data/4. Uni entry data/"

file_path_course_information <- glue(user_data_folder, "UAC courses reference data - ua15 to ua24.xlsx")

data_frame_course_information <- file_path_course_information |> 
  excel_sheets()
  
data_frame_course_information <-  data_frame_course_information %>% 
  set_names() |> 
  map(read_excel, path = file_path_course_information) |> 
  list_rbind() #binds all the worksheets into a single data frame as they have the same structure and variables, just a different year

file_path_school_leaver_results <- glue(user_data_folder, "UAC data for Grattan Institute - 2015 to 2024.xlsx")

data_frame_school_leaver_results <- file_path_school_leaver_results |> 
  excel_sheets() |> 
  setdiff("Notes") |> 
  set_names() |> 
  map(read_excel, path = file_path_school_leaver_results, col_types = "text") |> 
  list_rbind()
#sheets read as text, in case when the binding of list happens there are differences in how the variables are classified (perhaps due to diffenre coding) - e.g. numeric vs character etc. This avoids data loss. Will later need to reclassify them before can complete any analysis.
```

## List of degrees

```{r}

# Create list from the course description file (i.e. the orginal courses test file sent by UAC)
search_terms1 <- "^7"
search_terms2 <- c("educat|teach")

data_frame_course_information <- 
  data_frame_course_information |> 
  mutate(teaching_degree = 
           if_else(
             grepl(search_terms1,
                   field_of_study,
                   ignore.case = TRUE
           ), 
           T, 
              if_else(grepl(search_terms2,
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F)
           )
  )

course_names <- 
  filter(data_frame_course_information, 
       teaching_degree) |> 
  pull(course_desc_short) |> 
  unique()

#Output to MS Teams folder,as gitignore is set to ignore data folder, and these will be lost when we change branches.

#write.csv(course_names, glue(user_data_folder, "UAC_course_names.csv"))

# Create list from the teacher data (i.e. from the final dataset provided by UAC)
enrolled_counts <- 
  data_frame_school_leaver_results |> 
  filter(enrolment_status == "E") |> 
  count(course_desc_short) |> 
  arrange(-n)

#To help filter and classify the courses, identify courses with primary, secondary, special or specialist, or distance in the title, and save the data set.

#There's probably a way to use map() here, even with the boolean language. Come to that later. ChatGPT struggling to do it without using across(), and is repeatedly throwing up errors.
enrolled_counts <- enrolled_counts |>
  mutate(
    primary = if_else(grepl("primary",
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    secondary = if_else(grepl("secondary",
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    special = if_else(grepl("special",
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    distance = if_else(grepl("distance",
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    ece =  if_else(grepl(c("early|child|kinder"),
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    bachelor =  if_else(grepl(c("bachelor"),
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    diploma =  if_else(grepl(c("diploma|dip"),
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    master =  if_else(grepl(c("master"),
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F)
  )

#Save list to MS Teams
#write.csv(enrolled_counts, glue(user_data_folder, "UAC_course_by_enrolment.csv"))

#Check relative enrolments over time
#enrolled_counts |> count(primary, secondary, ece, special, distance, master)

#Get a list of the courses filtered out from the preliminary course list provided by UAC.
#setdiff(course_names, enrolled_counts$course_desc_short)
```

# Manually classify courses, read in the updated course file, and join it with the student level data set
```{r}
#Following manual review and classification in Excel of the courses in  UAC_course_by_enrolment.csv, created a new doc UAC_teaching_courses_by_enrolment.csv. Read this in and select only columns B, C and M (course_desc_short, n, and teaching_degree)

teaching_course_filters <- read.csv(glue(user_data_folder, "UAC_teaching_courses_by_enrolment.csv"))

teaching_course_counts <- teaching_course_filters |> 
    select(course_desc_short, n, teaching_degree) #Keep the counts of each course in case i need it at some point

#Combine with the UAC data set to classify the type of teaching course for each student. No need for course counts (complicates join). Then, filter out the non-teaching courses

classified_school_leaver_results <- data_frame_school_leaver_results |>
  left_join(select(teaching_course_counts,!n), by = "course_desc_short") |>
  filter(teaching_degree != "no")

# Re-classify the variables in classified_school_leaver_results, which are all mostly character variables due to read_excel specifying them as text, to avoid data loss.

classified_school_leaver_results <- classified_school_leaver_results %>%
  mutate(across(c(gender, enrolment_status, hsc_award, std1_band, std2_band, adv_band, ext1_band, ext2_band, teaching_degree), as.factor)) %>%
  mutate(across(c(hsc_year, ref_num, course_code, field_of_study, preference_num, std1_mark, std2_mark, adv_mark, ext1_mark, ext2_mark), as.numeric))

#glimpse(classified_school_leaver_results)

#Summarise teachers in each classification (over 10 years)
classification_counts <- classified_school_leaver_results |>
  group_by(teaching_degree) |> 
  count() 

```

#Overall enrolments by year

```{r}
#Count number of enrolled students in each year. Based on new data frame with irrelevant courses removed

classification_counts_year <- classified_school_leaver_results |> 
  filter(enrolment_status == "E") |>   
  count(hsc_year)

plot(classification_counts_year)
```

# Year 12 maths participation rates

```{r}
# Establish participation rate (proportion) in each Year 12 subject for primary teachers, and compare with secondary and all teachers (using various different definitions of primary and secondary, depending on what the course allows a student to complete)

# Define the set groups, as filtering condition for the following function. i.e. list which subgroup to explore. This is a named character vector. Names are subsequently used.

set_groups <- c(
  "All teachers" = "", 
  "Primary" = "primary", 
  "Primary or both" = "primary|both", 
  "Primary or either" = "primary|either", 
  "Primary or both or either" = "primary|both|either", 
  "Secondary" = "secondary", 
  "Secondary or both" = "secondary|both", 
  "Secondary or either" = "secondary|either", 
  "Secondary or both or either" = "secondary|both|either"
)

# Create a calculate_participation function, with the filtering condition as the input. 
calculate_participation <- function(group) {
  participation <- classified_school_leaver_results |> 
    filter(enrolment_status == "E") |> 
    filter(
      if (group == "") {
        TRUE  # Include all groups
      } else {
        teaching_degree %in% str_split(group, "\\|")[[1]]  # According to ChatGPT, necessary to give the if / else function the instruction to split strings by interpreting '|' as "or". It doesn't work using c(x, y) -  runs multiple string searches, not one with multiple conditions.
      }
    ) |> 
    select(ends_with("band")) |> 
    summarise(across(everything(), ~round(sum(!is.na(.))/n() * 100, 0))) #Assigns a 1 to every observation that isn't NA, then counts them, converts to rounded percentage. Does this for all the 'band' variables i.e. each subject. 
  
  return(participation)
}

# Create a tibble with participation data for each set_groups value
participation_rates_groups <- map2_dfr(names(set_groups), set_groups, ~ {
  calculate_participation(.y) |> 
    mutate(group_name = .x)  # Add a column for the set_group name
}) 

# Print the resulting tibble
print(participation_rates_groups)

```

# Chart the participation rates

```{r}

participation_long <- participation_rates_groups |> 
  pivot_longer(cols = ends_with("band"), 
               names_to = "subject", 
               values_to = "percentage")

# Create the grouped column chart. Not to be used (would need polishing)

ggplot(participation_long, aes(x = subject, y = percentage, fill = group_name)) +
  geom_col(position = "dodge") +  # Use dodge to create grouped columns
  labs(title = "Primary teaching students participated in easier Year 12 maths subjects",
       subtitle = "Participation rates in Year 12 mathematics subjects, 2014-2023, by type of teaching degree enrolment",
       x = NA,
       y = NA,
       fill = "group_name") +
  theme_grattan(legend = "bottom") 

```

# Year 12 maths performance - by mean score
#As above, but with mean score for each subject
```{r}
# Establish the mean performance in each Year 12 subject for primary teachers, and compare with secondary and all teachers (using various different definitions of primary and secondary, depending on what the course allows a student to complete)

# Define the set_groups, if different to above. (Here use same as above).

# Create a mean_score function, with the filtering condition as the input. 
mean_score <- function(group) {
  mean <- classified_school_leaver_results |> 
    filter(enrolment_status == "E") |> 
    filter(
      if (group == "") {
        TRUE  # Include all groups
      } else {
        teaching_degree %in% str_split(group, "\\|")[[1]]  # Split strings by interpreting '|' as "or". 
      }
    ) |> 
    select(ends_with("mark")) |> 
    summarise(across(everything(), ~round(mean(.x, na.rm = TRUE), 0))) #Take mean for all the 'mark' variables i.e. for each subject. 
  
  return(mean)
}

# Create a tibble with mean_score data for each set_groups value
mean_score_groups <- map2_dfr(names(set_groups), set_groups, ~ {
  mean_score(.y) |> 
    mutate(group_name = .x)  # Add a column for the set_group name
}) 

# Print the resulting tibble
print(mean_score_groups)


```

# Chart the mean scores

```{r}

mean_long <- mean_score_groups |> 
  pivot_longer(cols = ends_with("mark"), 
               names_to = "subject", 
               values_to = "percentage")

# Create the grouped column chart. Not to be used (would need polishing)

ggplot(mean_long, aes(x = subject, y = percentage, fill = group_name)) +
  geom_col(position = "dodge") +  # Use dodge to create grouped columns
  labs(title = "Primary and secondary teaching students had similar Year 12 results for Standard and Advanced mathematics",
       subtitle = "Mean scores in Year 12 mathematics subjects, 2014-2023, by type of teaching degree enrolment",
       x = NA,
       y = NA,
       fill = "group_name") +
  theme_grattan(legend = "bottom") 

```

# Year 12 maths performance - by band (proportion)

```{r}
# First, tidy up the variables to enable comparison and charting

# List the names of the variables ending in 'band' from classified_school_leaver_results

band_vars <- classified_school_leaver_results |> 
  select(ends_with("band")) |> 
  names()

# Identify the unique values of each band variable in the classified_school_leaver_results data frame, to use as the levels for the proportion calculation    

band_levels <- classified_school_leaver_results |> 
  select(ends_with("band")) |> 
  map(unique)

# View(band_levels)

# Create new variables in classified_school_leaver_results. First, create a variable mirroring ext1_band, as a factor, but with the letter 'E' removed from the front of all values that include it, with the levels redefined as 1, 2, 3 and 4. Then do the same for the variable ext2_band.

classified_school_leaver_results <- classified_school_leaver_results |> 
  mutate(ext1_num_band = as.factor(str_remove(ext1_band, "E")) |> 
           fct_relevel(c("1", "2", "3", "4")),
         ext2_num_band = as.factor(str_remove(ext2_band, "E")) |> 
           fct_relevel(c("1", "2", "3", "4")))

# To enable the band proportions to be summarised, need to make the number of levels / length of the variables the same. This will mean some levels have proportions of 0 in the summary. These can be clarified in the final output.

# Add levels 5 and 6 to the variables ext1_num_band and ext2_num_band, and relevel each with levels 1-6.

classified_school_leaver_results <- classified_school_leaver_results |> 
  mutate(ext1_num_band = fct_expand(ext1_num_band, c("5", "6")),
         ext2_num_band = fct_expand(ext2_num_band, c("5", "6"))) |> 
  mutate(ext1_num_band = fct_relevel(ext1_num_band, c("1", "2", "3", "4", "5", "6")),
         ext2_num_band = fct_relevel(ext2_num_band, c("1", "2", "3", "4", "5", "6")))

# For the variable std1_band, add levels 1 and 2, and  relevel with levels 1-6.

classified_school_leaver_results <- classified_school_leaver_results |> 
  mutate(std1_num_band = fct_expand(std1_band, c("1", "2")),
         std1_num_band = fct_relevel(std1_num_band, c("1", "2", "3", "4", "5", "6")))

# Re-run the band_levels code to check that the new variables have been created correctly

band_levels <- classified_school_leaver_results |> 
  select(ends_with("band")) |> 
  map(unique) 

View(band_levels)

```

```{r}
# Create the data to make a stacked bar chart of the proportion of students in each band for each subject, by type of teaching degree enrolment. 

#Define the groups more narrowly given that adding the eithers and boths is marginal to the analysis. 

set_groups2 <- c(
  "All teachers" = "", 
  "Primary" = "primary", 
  "Secondary" = "secondary" 
)

# Define the subjects to be analysed
subjects <- c("std1_num_band", "std2_band", "adv_band", "ext1_num_band", "ext2_num_band")

# For each group (set_groups2), summarise the proportion of students in each band (level) for each of the subjects. 

# Function to calculate proportions for each 'band' variable individually
calculate_band_proportion <- function(group) {
  classified_school_leaver_results |> 
    filter(enrolment_status == "E") |> 
    filter(
      if (group == "") {
        TRUE  # Include all groups
      } else {
        teaching_degree %in% group 
      }
    ) |> 
    select(subjects) |>  # Select the subjects
    # Calculate proportions for each band
    map_dfr(~ {
      proportions <- round(prop.table(table(.x)) * 100, 0)  # Calculate the proportions
      tibble(
        Level_1 = proportions["1"] %||% NA,
        Level_2 = proportions["2"] %||% NA,
        Level_3 = proportions["3"] %||% NA,
        Level_4 = proportions["4"] %||% NA,
        Level_5 = proportions["5"] %||% NA,
        Level_6 = proportions["6"] %||% NA
      )
    }, .id = "subject")  # Use the subject name as an identifier
}


# Run the function for each set_groups2 value
band_proportion_groups <- map2_dfr(names(set_groups2), set_groups2, ~ {
  band_proportion <- calculate_band_proportion(.y)
  tibble(group_name = .x, band_proportion = band_proportion)  # Return a tibble with group and proportions
}) |> 
  #Unpack the tables in column 2 into multiple columns
  unnest_wider(band_proportion)
  
# Print the resulting tibble
print(band_proportion_groups)

# Gather the data to enable a stacked bar chart to be created

band_proportion_groups_long <- band_proportion_groups |> 
  pivot_longer(cols = -c(group_name, subject),
               names_to = "band", 
               values_to = "proportion")

print(band_proportion_groups_long)
```

# Chart the bands stacked - differnet chart for each subject.

```{r}

# Write a function based on the band_proportion_groups_long tibble, which filters the subject variable by an input value, and creates a stacked bar chart with x = group_name, y = proportion, fill = band.


band_proportion_chart <- function(selected_subject) {
  band_proportion_groups_long |> 
    filter(subject == !!selected_subject) |> 
    ggplot(aes(x = group_name,
               y = proportion, 
               fill = band)) +  
    geom_col(position = "stack") +
    theme_grattan() +
    scale_fill_grattan(discrete = T) +
    grattan_y_continuous(labels = NULL, limits =c(0,100), breaks = seq(0, 100, by = 20)) +
    labs(title = "Primary teachers achieve similar Year 12 maths results to secondary teachers",
         subtitle = glue("Proportion of teaching students whose Year 12 maths results were in<br>performance bands {colour_text(grattan_red, '1')} ,2, 3, 4, 5 or 6, for each year subject"),
         x = NULL, 
         y = NULL) +
    theme(plot.subtitle = element_markdown()) 
}

# Define the selected_subject variable as the unique values of band_proportion_groups_long$subjects variable.

selected_subjects <- band_proportion_groups_long |> 
  pull(subject) |> 
  unique()

# Map the selected_subjects to the band_proportion_chart function.

band_proportion_charts <- map(selected_subjects, band_proportion_chart)

# Save all of these using grattan_save_all.  ###Not working. Syntax of grattan_save_all seems wrong. grattan_save_pptx not processing the .y argument.

#grattan_save_all(filename = glue(user_data_folder, "band_proportion_chart_{.y}.pdf"), object = band_proportion_charts, type = "all")

#grattan_save_pptx(filename = glue(user_data_folder, "band_proportion_chart_{.y}.pptx", object = band_proportion_charts, type = "fullslide"))
```
  

# Chart the band stacked and dodged  ###NEEDS WORK. DOESN'T WANT TO STACK AND DODGE ###

```{r}
# Define order of colours in stacked chart
# ordered_colours <- c(
#  "neg_needs_additional_support_percent" = grattan_red,
#  "neg_developing_percent" = grattan_darkorange,
#  "strong_percent" = grattan_orange,
#  "exceeding_percent" = grattan_yellow
# )

#Create stacked, dodge chart
band_proportions_chart <- band_proportion_groups_long |> 
ggplot(aes(x = subject,
           y = proportion, 
           fill = band, 
           group = group_name)) +  
geom_col(position = position_dodge2(width = 0.5)) +
  
#data labels on chart
geom_text(aes(label = paste0(proportion, "%"),
              y = proportion, 
              color = T,
              group = band,
              vjust = if_else(proportion < 5, -1, 0.5)),
          size = 18/.pt,    
          position = position_stack(vjust = 0.5),
          ) +
  
# theme and labels
theme_grattan() +
scale_fill_grattan(discrete = T) +
#scale_fill_manual(values = ordered_colours) +
grattan_y_continuous(labels = NULL, limits =c(0,100), breaks = seq(0, 100, by = 20)) +
#scale_x_discrete(expand = expansion(mult = c(0, 0.5))) +
scale_colour_manual(values = c("white", "black")) +
labs(title = "Primary teachers achieve similar Year 12 maths results to secondary teachers",
     subtitle = glue("Proportion of teaching students whose Year 12 maths results were in performance bands {colour_text(grattan_red, '1')} ,2, 3, 4, 5 or 6, for each year subject"),
     x = NULL, 
     y = NULL) +
theme(plot.subtitle = element_markdown()) 

print(band_proportions_chart)

#grattan_save_all("atlas/proficiency_chart_2024.pdf", proficiency_chart_2024)
#grattan_save_pptx(filename = "atlas/proficiency_chart_2024.pptx", proficiency_chart_2024)

```

# Year 12 maths performance - by band (number of students)

```{r}
# Create the data to make a grouped column chart of the number of students in each band for each subject, by type of teaching degree enrolment. 

#Use set_groups2 and subjects from above. 

# For each group (set_groups2), summarise the number of students in each band (level) for each of the subjects. 

# Function to calculate number for each 'band' variable individually
calculate_band_number <- function(group) {
  classified_school_leaver_results |> 
    filter(enrolment_status == "E") |> 
    filter(
      if (group == "") {
        TRUE  # Include all groups
      } else {
        teaching_degree %in% group 
      }
    ) |> 
    select(subjects) |>  # Select the subjects
    # Calculate proportions for each band
    map_dfr(~ {
      numbers <- round(table(.x), 0)  # Calculate the numbers
      tibble(
        Level_1 = numbers["1"] %||% NA,
        Level_2 = numbers["2"] %||% NA,
        Level_3 = numbers["3"] %||% NA,
        Level_4 = numbers["4"] %||% NA,
        Level_5 = numbers["5"] %||% NA,
        Level_6 = numbers["6"] %||% NA
      )
    }, .id = "subject")  # Use the subject name as an identifier
}

# Run the function for each set_groups2 value
band_number_groups <- map2_dfr(names(set_groups2), set_groups2, ~ {
  band_numbers <- calculate_band_number(.y)
  tibble(group_name = .x, band_numbers = band_numbers)  # Return a tibble with group and student numbers
}) |> 
  #Unpack the tables in column 2 into multiple columns
  unnest_wider(band_numbers)
  
# Print the resulting tibble
print(band_number_groups)

# Gather the data to enable a grouped bar chart to be created (if needed)

band_number_groups_long <- band_number_groups |> 
  pivot_longer(cols = -c(group_name, subject),
               names_to = "band", 
               values_to = "number")

print(band_proportion_groups_long)
```

# Output data on performance

```{r}
# Output the band_proportion_groups and band_number_groups data to a CSV file with 2 worksheets
 
library(writexl)

# Create a named list of data frames, where names correspond to the worksheet names
data_frames <- list(
  "band_proportions" = band_proportion_groups, 
  "band_numbers" = band_number_groups,
  "mean_scores" = mean_score_groups
)

# Output the data to an Excel file 
output_file <- glue(user_data_folder, "UAC_band_performance_data.xlsx")

# Write to Excel file
write_xlsx(x = data_frames, path = output_file)


```

#Assemble data from NSW UAC reports on student performance by subject and band

```{r}

# ChatGPT/Bing code used to extract data from the UAC reports:

# Please complete the following r code with a new line for each mathematics subject, from the document I just uploaded.
# The document source is https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2022-nsw-hsc.pdf
# Please use the exact course name specified for the subject.
# For extension subjects, the percentages for Level6 and Level5 are both NA.
# For Level1, please calculate the percentage (as 100 less the sum of the percentages for Levels 2-6) or if the answer would be 0, then include 0 (not NA).


tribble(
  ~year, ~subject, ~number, ~median, ~Level6, ~Level5, ~Level4, ~Level3, ~Level2, ~Level1, ~source 
  2023,

#Level 1 scores were calculated by chatgpt (as 100-sum(L2-6) ) and will need to be cross checked for accuracy later.
tribble(
  ~year, ~subject, ~number, ~median, ~Level6, ~Level5, ~Level4, ~Level3, ~Level2, ~Level1, ~source,
  2023, "Mathematics Standard 1", 1608, 72, 3, 18, 40, 30, 7, 2, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2023-nsw-hsc.pdf",
  2023, "Mathematics Standard 2", 30805, 73, 9, 22, 26, 24, 14, 5, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2023-nsw-hsc.pdf",
  2023, "Mathematics Advanced", 16428, 79, 22, 27, 26, 18, 6, 1, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2023-nsw-hsc.pdf",
  2023, "Mathematics Extension 1", 8390, 82, NA, NA, 34, 38, 24, 4, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2023-nsw-hsc.pdf",
  2023, "Mathematics Extension 2", 3273, 86, NA, NA, 38, 48, 13, 1, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2023-nsw-hsc.pdf"
  2022, "Mathematics Standard 1", 1410, 73, 4, 23, 38, 23, 10, 2, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2022-nsw-hsc.pdf",
  2022, "Mathematics Standard 2", 29874, 71, 7, 22, 25, 28, 15, 3, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2022-nsw-hsc.pdf",
  2022, "Mathematics Advanced", 16865, 79, 23, 26, 27, 18, 5, 1, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2022-nsw-hsc.pdf",
  2022, "Mathematics Extension 1", 8679, 82, NA, NA, 35, 39, 20, 6, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2022-nsw-hsc.pdf",
  2022, "Mathematics Extension 2", 3271, 86, NA, NA, 40, 46, 11, 3, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2022-nsw-hsc.pdf"
  2021, "Mathematics Standard 1", 1461, 70, 4, 15, 32, 32, 13, 4, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2021-nsw-hsc.pdf",
  2021, "Mathematics Standard 2", 30035, 70, 6, 19, 27, 27, 15, 6, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2021-nsw-hsc.pdf",
  2021, "Mathematics Advanced", 16769, 80, 23, 27, 29, 15, 4, 2, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2021-nsw-hsc.pdf",
  2021, "Mathematics Extension 1", 8547, 42, NA, NA, 37, 37, 20, 6, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2021-nsw-hsc.pdf",
  2021, "Mathematics Extension 2", 3193, 88, NA, NA, 43, 44, 12, 1, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2021-nsw-hsc.pdf"
  2020, "Mathematics Standard 1", 1340, 71, 3, 14, 39, 27, 13, 4, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2020-nsw-hsc.pdf",
  2020, "Mathematics Standard 2", 30026, 70, 5, 19, 26, 25, 17, 8, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2020-nsw-hsc.pdf",
  2020, "Mathematics Advanced", 16771, 80, 23, 29, 28, 15, 3, 2, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2020-nsw-hsc.pdf",
  2020, "Mathematics Extension 1", 8804, 84, NA, NA, 38, 37, 20, 5, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2020-nsw-hsc.pdf",
  2020, "Mathematics Extension 2", 3372, 86, NA, NA, 36, 48, 13, 3, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2020-nsw-hsc.pdf"
  2019, "Mathematics Standard 1", 1139, 71, 3, 14, 39, 28, 13, 3, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2019-nsw-hsc.pdf",
  2019, "Mathematics Standard 2", 29656, 72, 5, 19, 32, 27, 13, 4, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2019-nsw-hsc.pdf",
  2019, "Mathematics", 17311, 79, 24, 26, 29, 14, 5, 2, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2019-nsw-hsc.pdf",
  2019, "Mathematics Extension 1", 8830, 43, NA, NA, 39, 41, 15, 5, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2019-nsw-hsc.pdf",
  2019, "Mathematics Extension 2", 3134, 85, NA, NA, 36, 50, 11, 3, "https://www.uac.edu.au/assets/documents/scaling-reports/scaling-report-2019-nsw-hsc.pdf"
  2018, "Mathematics General 2", 30824, 71, 7, 20, 26, 27, 15, 5, "https://www.uac.edu.au/assets/documents/scaling-reports/Scaling-Report-2018-NSW-HSC.pdf",
  2018, "Mathematics", 17825, 80, 23, 29, 26, 15, 5, 2, "https://www.uac.edu.au/assets/documents/scaling-reports/Scaling-Report-2018-NSW-HSC.pdf",
  2018, "Mathematics Extension 1", 9021, 41, NA, NA, 33, 47, 17, 3, "https://www.uac.edu.au/assets/documents/scaling-reports/Scaling-Report-2018-NSW-HSC.pdf",
  2018, "Mathematics Extension 2", 3164, 85, NA, NA, 33, 52, 12, 3, "https://www.uac.edu.au/assets/documents/scaling-reports/Scaling-Report-2018-NSW-HSC.pdf"
  
)

  

```
