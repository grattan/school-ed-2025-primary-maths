---
title: "Analysis of UAC data"
output:
  bookdown::html_document2:
    css: .formatting/grattan-style.css
    theme: lumen
    highlight: pygments
    toc: yes
    toc_depth: 2
    toc_float: no
    number_sections: yes
    df_print: kable
---

```{r logo, echo=FALSE}
# This adds the grattan logo to the document (cute)
htmltools::img(src = knitr::image_uri(file.path(".formatting", "logo", "GrattanLogo_left.png")), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; height:8%;')
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE, 
                      message = FALSE)

source("R/00-setup.R") 

rebuild_data <- FALSE
```

# Import data

```{r}

#Upload the !!Preliminary!! course list provided to Grattan. 
#Note - UAC subsequently filtered that down, in the data set ultimately provided to us, using filters: field of study code (broad FOS = 7) or any course with description including the string “Educat” or “Teach”. 

user_data_folder <- "C:/Users/PETRIE/The University of Melbourne/2024 Primary schools maths - General/3. Data/4. Uni entry data/"
#"C:/Users/parkinsonn/The University of Melbourne/2024 Primary schools maths - General/3. Data/4. Uni entry data/"

file_path_course_information <- glue(user_data_folder, "UAC courses reference data - ua15 to ua24.xlsx")

data_frame_course_information <- file_path_course_information |> 
  excel_sheets()
  
data_frame_course_information <-  data_frame_course_information %>% 
  set_names() |> 
  map(read_excel, path = file_path_course_information) |> 
  list_rbind()

file_path_school_leaver_results <- glue(user_data_folder, "UAC data for Grattan Institute - 2015 to 2024.xlsx")

data_frame_school_leaver_results <- file_path_school_leaver_results |> 
  excel_sheets() |> 
  setdiff("Notes") |> 
  set_names() |> 
  map(read_excel, path = file_path_school_leaver_results, col_types = "text") |> 
  list_rbind()

```

## List of degrees

```{r}

# From the course description
search_terms1 <- "^7"
search_terms2 <- c("educat|teach")

data_frame_course_information <- 
  data_frame_course_information |> 
  mutate(teaching_degree = 
           if_else(
             grepl(search_terms1,
                   field_of_study,
                   ignore.case = TRUE
           ), 
           T, 
              if_else(grepl(search_terms2,
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F)
           )
  )

course_names <- 
  filter(data_frame_course_information, 
       teaching_degree) |> 
  pull(course_desc_short) |> 
  unique()

write.csv(course_names, glue(user_data_folder, "UAC_course_names.csv"))

# From the teacher data
enrolled_counts <- 
  data_frame_school_leaver_results |> 
  filter(enrolment_status == "E") |> 
  count(course_desc_short) |> 
  arrange(-n)

#To help filter and classify the courses, identify courses with primary, secondary, special or specialist, or distance in the title, and save the data set.

#There's probably a way to use map() here, even with the boolean language. Come to that later. ChatGPT struggling to do it without using across(), and is repeatedly throwing up errors.
enrolled_counts <- enrolled_counts |>
  mutate(
    primary = if_else(grepl("primary",
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    secondary = if_else(grepl("secondary",
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    special = if_else(grepl("special",
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    distance = if_else(grepl("distance",
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    ece =  if_else(grepl(c("early|child|kinder"),
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    bachelor =  if_else(grepl(c("bachelor"),
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    diploma =  if_else(grepl(c("diploma|dip"),
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F),
    master =  if_else(grepl(c("master"),
                   course_desc_short,
                   ignore.case = TRUE
              ), 
              T, 
              F)
  )

write.csv(enrolled_counts, glue(user_data_folder, "UAC_course_by_enrolment.csv"))

#enrolled_counts |> count(primary, secondary, ece, special, distance, master)

#Get a list of the courses filtered out from the preliminary course list provided by UAC.
#setdiff(course_names, enrolled_counts$course_desc_short)

#Following manual review and classification in Excel of the courses in  UAC_course_by_enrolment.csv, created a new doc UAC_teaching_courses_by_enrolment.csv. Read this in and select only columns B, C and M (course_desc_short, n, and teaching_degree)

teaching_course_filters <- read.csv(glue(user_data_folder, "UAC_teaching_courses_by_enrolment.csv"))

teaching_course_counts <- teaching_course_filters |> 
    select(course_desc_short, n, teaching_degree)

#Combine with the UAC data set to classify the type of teaching course for each student. Filter out the non-teaching courses

classified_school_leaver_results <- data_frame_school_leaver_results |>
  left_join(select(teaching_course_counts,!n), by = "course_desc_short") |>
  filter(teaching_degree != "no")

# Re-classify the variables in classified_school_leaver_results, which are all mostly character variables due to read_excel specifying them as text, to avoid data loss.

classified_school_leaver_results <- classified_school_leaver_results %>%
  mutate(across(c(gender, enrolment_status, hsc_award, std1_band, std2_band, adv_band, ext1_band, ext2_band, teaching_degree), as.factor)) %>%
  mutate(across(c(hsc_year, ref_num, course_code, field_of_study, preference_num, std1_mark, std2_mark, adv_mark, ext1_mark, ext2_mark), as.numeric))

#glimpse(classified_school_leaver_results)

classification_counts <- classified_school_leaver_results |>
  group_by(teaching_degree) |> 
  count() 

```

#Overall enrolments by year

```{r}
#Count number of enrolled students in each year. Based on new data frame with irrelevant courses removed

classification_counts_year <- classified_school_leaver_results |> 
  filter(enrolment_status == "E") |>   
  count(hsc_year)

plot(classification_counts_year)
```

# Year 12 maths participation rates

```{r}
# Establish participation rate (proportion) in each Year 12 subject for primary teachers, and compare with secondary and all teachers (using different definitions of primary and secondary)

# Define the set groups
set_groups <- c(
  "All teachers" = "", 
  "Primary" = "primary", 
  "Primary or both" = "primary|both", 
  "Primary or either" = "primary|either", 
  "Primary or both or either" = "primary|both|either", 
  "Secondary" = "secondary", 
  "Secondary or both" = "secondary|both", 
  "Secondary or either" = "secondary|either", 
  "Secondary or both or either" = "secondary|both|either"
)

# Update the calculate_participation function to handle 'or' conditions
calculate_participation <- function(set_group) {
  participation <- classified_school_leaver_results |> 
    filter(enrolment_status == "E") |> 
    filter(
      if (set_group == "") {
        TRUE  # Include all groups
      } else {
        teaching_degree %in% str_split(set_group, "\\|")[[1]]  # Split string by '|'
      }
    ) |> 
    select(ends_with("band")) |> 
    summarise(across(everything(), ~round(sum(!is.na(.))/n() * 100, 0)))
  
  return(participation)
}

# Create a tibble with participation data for each set_group value
participation_rates_groups <- map2_dfr(names(set_groups), set_groups, ~ {
  calculate_participation(.y) |> 
    mutate(set_group_name = .x)  # Add a column for the set_group name
}) 

# Print the resulting tibble
print(participation_rates_groups)

```

# Chart the participation rates

```{r}

participation_long <- participation_rates_groups |> 
  pivot_longer(cols = ends_with("band"), 
               names_to = "subject", 
               values_to = "percentage")

# Create the grouped column chart. Not to be used (would need polishing)

ggplot(participation_long, aes(x = subject, y = percentage, fill = set_group_name)) +
  geom_col(position = "dodge") +  # Use dodge to create grouped columns
  labs(title = "Primary teaching students participated in easier Year 12 maths subjects",
       subtitle = "Participation rates in Year 12 mathematics subjects by type of teaching students",
       x = NA,
       y = NA,
       fill = "set_group_name") +
  theme_grattan(legend = "bottom") 

```

#Update the above
#Let's go back and rename all the subjects with current equivalents also


# Year 12 maths performance - by score
#As above, but with mean score for each subject 


# Year 12 maths performance - by band
#Tibble as above but with proportion in each band for each subject. Consider if the proportion of all studnets or of students taking the subject. 
#May need to do a tibble per subject. TBC if we care about every suject




